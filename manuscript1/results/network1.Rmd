---
title: "crop health network"
author: "Sith J"
date: "September 30, 2015"
output: html_document
---

Here is the report of the network analysis of the crop health data.

```{r loading the libraries, echo = TRUE, warning = FALSE, message = FALSE}
require(dplyr)
library(plyr)
require(reshape)
require(reshape2)
library(gridExtra)
library(lubridate)
library(doBy)
library(cluster)
library(ggplot2)
library(scales)
library(bioDist)
library(vegan)
library(mvtnorm)
library(igraph)
library(WGCNA)
library(cowplot)
```

Load the survey data

```{r echo = TRUE, warning = FALSE, message = FALSE}
library(RCurl)
file <- getURL("https://docs.google.com/spreadsheets/d/1zB7gNdI7Nk7SuHuPWcjzaKnjuwkvL6sOVMo0zMfuV-c/pub?gid=558862364&single=true&output=csv")
data <- read.csv(text = file)
# save(data, file = "manuscript1/data/skep1data.RData")
#load(file = "manuscript1/data/skep1data.RData")
#Filepath <- "~/Google Drive/1.SKEP1/SKEP1survey.xls"
#data <- readWorksheetFromFile(Filepath, sheet = 1)
```

```{r define the NA}
data[data == "-"] <- NA # replace '-' with NA
data[data == ""] <- NA # replace 'missing data' with NA

#==== to lower variable names ====
names(data) <- tolower(names(data)) # for more consistancy
```

select out the column which is not inlcuded in the analysis

```{r select out}
data$phase <- NULL # there is only one type yype of phase in the survey
data$identifier <- NULL # this variable is not included in the analysis
data$village <- NULL
data$year <- NULL
data$season <- NULL
data$lat <- NULL
data$long <- NULL
data$fa <- NULL # field area is not include in the analysis
data$fn <- NULL # farmer name can not be included in this survey analysis
data$fp <- NULL # I do not know what is fp
data$lfm <- NULL # there is only one type of land form in this survey
data$ced <- NULL # Date data can not be included in the network analysis
data$cedjul <- NULL
data$hd <- NULL # Date data can not be included in the network analysis
data$hdjul <- NULL
data$cvr <- NULL
data$varcoded <- NULL # I will recode them 
data$fymcoded <- NULL
data$mu <- NULL # no record
data$nplsqm <- NULL
data$rbpx <- NULL # no record
```


```{r}
#==== corract the variable type =====
data <- transform(data, 
                  country = as.factor(country),
                  pc = as.factor(pc),
                  cem = as.factor(cem),     
                  ast = as.factor(ast),       
                  ccd = as.numeric(ccd),
                  vartype = as.factor(vartype),
                  fym = as.character(fym),
                  n = as.numeric(n),
                  p = as.numeric(p) ,
                  k = as.numeric(k),
                  mf = as.numeric(mf),        
                  wcp = as.factor(wcp),      
                  iu = as.numeric(iu),     
                  hu = as.numeric(hu),      
                  fu = as.numeric(fu),      
                  cs  = as.factor(cs),      
                  ldg  =  as.numeric(ldg),  
                  yield = as.numeric(yield) ,
                  dscum = as.factor(dscum),   
                  wecum = as.factor(wecum),   
                  ntmax = as.numeric(ntmax), 
                  npmax = as.numeric(npmax),    
                  nltmax = as.numeric(nltmax),  
                  nlhmax = as.numeric(nltmax),  
                  waa = as.numeric(waa),      
                  wba = as.numeric(wba) ,   
                  dhx =  as.numeric(dhx),  
                  whx =  as.numeric(whx),     
                  ssx  = as.numeric(ssx),  
                  wma = as.numeric(wma), 
                  lfa = as.numeric(lfa),
                  lma = as.numeric(lma),   
                  rha  = as.numeric(rha) ,
                  thrx = as.numeric(thrx),    
                  pmx = as.numeric(pmx),    
                  defa  = as.numeric(defa) ,
                  bphx = as.numeric(bphx),   
                  wbpx = as.numeric(wbpx),    
                  awx  = as.numeric(awx), 
                  rbx =as.numeric(rbx),   
                  rbbx = as.numeric(rbbx),  
                  glhx  = as.numeric(glhx), 
                  stbx=as.numeric(stbx),    
                  hbx= as.numeric(hbx),
                  bbx = as.numeric(bbx),    
                  blba = as.numeric(blba),    
                  lba = as.numeric(lba),    
                  bsa = as.numeric(bsa),    
                  blsa = as.numeric(blsa),  
                  nbsa = as.numeric(nbsa),  
                  rsa  = as.numeric(rsa),   
                  lsa = as.numeric(lsa),    
                  shbx = as.numeric(shbx) ,  
                  shrx = as.numeric(shrx),    
                  srx= as.numeric(srx),    
                  fsmx = as.numeric(fsmx),   
                  nbx =  as.numeric(nbx),   
                  dpx = as.numeric(dpx),    
                  rtdx  = as.numeric(rtdx),  
                  rsdx  = as.numeric(rsdx),
                  gsdx  =as.numeric(gsdx),   
                  rtx = as.numeric(rtx)
) 
```

```{r coding the data}
data$pc <- ifelse(data$pc == "rice", 1, 0)

#Crop establisment method
levels(data$cem)[levels(data$cem) == "trp"] <- 1
levels(data$cem)[levels(data$cem) == "TPR"] <- 1
levels(data$cem)[levels(data$cem) == "DSR"] <- 2
levels(data$cem)[levels(data$cem) == "dsr"] <- 2

# fym there are two type 0 and 1, raw data are recorded as no, yes, and value, if the value is 0 which mean 0 and if the value more than 0 which means 1 

data$fym <- ifelse(data$fym == "no", 0, 
                   ifelse(data$fym == "0", 0, 1
                   )
)

# vartype there are three type treditional varieties, modern varities and hybrid
data$vartype <- ifelse(data$vartype == "tv", 1,
                       ifelse(data$vartype == "mv", 2,
                              ifelse(data$vartype == "hyb", 3, NA
                              )
                       )
)


# wcp weed control management
levels(data$wcp)[levels(data$wcp) == "hand"] <- 1
levels(data$wcp)[levels(data$wcp) == "herb"] <- 2
levels(data$wcp)[levels(data$wcp) == "herb-hand"] <- 3


# Crop Status
levels(data$cs)[levels(data$cs) == "very poor"] <- 1
levels(data$cs)[levels(data$cs) == "poor"] <- 2
levels(data$cs)[levels(data$cs) == "average"] <- 3
levels(data$cs)[levels(data$cs) == "good"] <- 4
levels(data$cs)[levels(data$cs) == "very good"] <- 5

```

```{r}
#clean the data
num.data <- apply(data[, -c(1,2)], 2, as.numeric)
num.data <- as.data.frame(as.matrix(num.data))
data <- cbind(data[1:2], num.data)
data <- data[,apply(data[, -c(1,2)], 2, var, na.rm = TRUE) != 0] # exclude the column with variation = 0
data <- data[complete.cases(data),] # exclude row which cantain NA
```

```{r}
#==== cluster analysis of the production sitatuon of the survey data ====
start.PS <- "pc"
end.PS <- "fu"
start.col.PS <- match(start.PS, names(data))
end.col.PS <- match(end.PS, names(data))

PS.data <- data[, c(1, start.col.PS:end.col.PS)]

# transform all variable to numeric type

# wss <- (nrow(PS.data)-1)* sum(apply(PS.data, 2, var))
# for (i in 2:15) wss[i] <- sum(kmeans(PS.data, 
#                                      centers=i)$withinss)
# plot(1:15, wss, type="b", xlab="Number of Clusters",
#      ylab="Within groups sum of squares")


#distance matrix
dist.PS <- daisy(PS.data[-1])

cluster.PS <- hclust(dist.PS, method = "average")

dendro.PS <- as.dendrogram(cluster.PS)
plot(dendro.PS, center = T, nodePar = list(lab.cex = 0.6,
                                          lab.col = "black", pch = NA),
     main = "Dendrogram for Production situation")

# draw retangles
rect.hclust(tree = cluster.PS, k=2, border = c("red", "blue"))

#number of members in each cluster
PS.no <- cutree(cluster.PS, k = 2)

# cophenitic correlation
rcluster.PS <- cophenetic(cluster.PS)
#cor(dist.PS, rcluster.PS)

data <- cbind(data, PS.no)
data$PS.no <- as.factor(data$PS.no)
```


```{r}
name.country <- levels(data$country)
by.country.data <- list()
for(i in 1:length(name.country)){
  temp <- data %>% 
    filter(country == name.country[i])
  by.country.data[[i]] <- temp
}
```

```{r}
g <- ggplot(data, aes(x = country)) +
    geom_histogram(weights = count) +
    stat_bin(geom = "text", aes(label = ..count..), vjust = 1.5, color = "white" ) +
  scale_y_continuous(limits = c(0, 125), breaks = NULL ) +
  theme(legend.position = "none") +
  ggtitle("The no of observation of dataset in each country")
print(g)
```


```{r bunch_o_figs_svg, fig.height = 3, fig.width = 3, dev='svg'}
par(mfrow=c(1, 2), las = 1)
for(i in 1:length(name.country)) {
g <- ggplot(by.country.data[[i]], aes(x = PS.no)) +
    geom_histogram(weights = count) +
    ggtitle(paste("Histogram PS cluster of", name.country[i])) +
  theme(legend.position="none")
print(g)   
}
```

```{r fig.height = 3, fig.width = 3, dev='svg'}
# The profile of PS no 
clus.PS.data <- data[, -c(1, 17:56)]
m.PS.data <- melt(clus.PS.data)
name.variable <- levels(m.PS.data$variable)
name.PS.no <- levels(m.PS.data$PS.no)
# check the profile of each cluster by histogram 

for(i in 1:length(name.variable)) {
  subtemp <- subset(m.PS.data, variable == name.variable[i])
  for(j in 1: length(name.PS.no)){
    subtemp1 <- subtemp %>% filter(PS.no == name.PS.no[j])
   g <-  ggplot(subtemp1, aes(x = value)) + 
   geom_bar(aes(y = (..count..)/sum(..count..)), binwidth = 1) + 
  scale_y_continuous(limits = c(0, 1), labels = percent) +
ylab("Percent") + xlab(paste(name.variable[i]))
  ggtitle(paste("Histogram of", name.variable[i], "in PS. no", name.PS.no[j]))
print(g) 
  }
}
```

Network analysis
```{r}
#head(data)
# select only the variables related to the injury profiles

start.IP <- "dhx"
end.IP <- "rtx"
start.col.IP <- match(start.IP, names(data))
end.col.IP <- match(end.IP, names(data))

IP.data <- data[start.col.IP:end.col.IP]

IP.data <- IP.data[ ,apply(IP.data, 2, var, na.rm = TRUE) != 0] # exclude the column with variation = 0

groups <- paste(data$country, data$PS.no, sep = "_")

IP.data <- cbind(groups, IP.data)

IP.data[is.na(IP.data)] <- 0

trts <- as.vector(unique(IP.data$groups))
```


```{r, warning= FALSE, message=FALSE}
#=====co_occurrence_pairwise.R====
results <- matrix(nrow = 0, ncol = 7)
options(warnings = -1)
for(a in 1:length(trts)){
  #pull the first element from the vector of treatments
  trt.temp <- trts[a]
  #subset the dataset for those treatments
  temp <- subset(IP.data, groups == trt.temp)
  
  #in this case the community data started at column 6, so the loop for co-occurrence has to start at that point
  for(b in 2:(dim(temp)[2]-1)){
    #every species will be compared to every other species, so there has to be another loop that iterates down the rest of the columns
    for(c in (b+1):(dim(temp)[2])){
      
      #summing the abundances of species of the columns that will be compared
      species1.ab <- sum(temp[,b])
      species2.ab <- sum(temp[,c])
      #if the column is all 0's no co-occurrence will be performed
      if(species1.ab >1 & species2.ab >1){
        test <- cor.test(temp[,b], temp[,c], method = "spearman", na.action = na.rm, exact = FALSE)
        # There are warnings when setting exact = TRUE because of ties from the output of Spearman's correlation
        # stackoverflow.com/questions/10711395/spear-man-correlation and ties
        # It would be still valid if the data is not normally distributed.
        rho <- test$estimate
        p.value <- test$p.value
      }
      
      if(species1.ab <=1 | species2.ab <= 1){
        rho<-0
        p.value<-1
      }	
      
      new.row <- c(trts[a], names(temp)[b], names(temp)[c], rho, p.value, species1.ab, species2.ab)
      results <- rbind(results, new.row)			
      
    }
    
  }
  print(a/length(trts))
  
}

results<-data.frame(data.matrix(results))
names(results)<-c("trt","taxa1","taxa2","rho","p.value","ab1","ab2")

#making sure certain variables are factors
results$trt <- as.factor(results$trt)
results$taxa1 <- as.character(as.factor(results$taxa1))
results$taxa2 <- as.character(as.factor(results$taxa2))
results$rho <- as.numeric(as.character(results$rho))
results$p.value <- as.numeric(as.character(results$p.value))
results$ab1 <- as.numeric(as.character(results$ab1))
results$ab2 <- as.numeric(as.character(results$ab2))

str(results)
head(results)
```

```{r}
results_sub <- subset(results, as.numeric(as.character(abs(rho))) > 0.25)

results_sub.by.group <- list()
name.groups <- sort(as.vector(unique(groups)))
```


```{r , fig.align ='center', fig.height = 6, fig.width = 6, dev='svg'}
for(i in 1: length(name.groups)){
  
  results_sub.by.group[[i]] <- subset(results_sub, trt == name.groups[i])
}

# head(results_sub.by.group[[1]][,2:3]) # get the list

g  <- list()
for(i in 1:length(name.groups)){
  g[[i]] <- graph.edgelist(as.matrix(results_sub.by.group[[i]][,2:3]), directed = FALSE)
#== adjust layout
l <- layout.fruchterman.reingold(g[[i]])
#== adjust vertices

V(g[[i]])$color <- "tomato"
V(g[[i]])$frame.color <- "gray40"
V(g[[i]])$shape <- "circle"
V(g[[i]])$size <- 25
V(g[[i]])$label.color <- "white"
V(g[[i]])$label.font <- 2
V(g[[i]])$label.family <- "Helvetica"
V(g[[i]])$label.cex <- 0.7

#== adjust the edge
E(g[[i]])$weight <- as.matrix(results_sub.by.group[[i]][, 4])
E(g[[i]])$width <- 1 + E(g[[i]])$weight*5

col <- c("firebrick3", "forestgreen")
colc <- cut(results_sub.by.group[[i]]$rho, breaks = c(-1, 0, 1), include.lowest = TRUE)
E(g[[i]])$color <- col[colc]

#== plot network model
plot(g[[i]], layout = l * 1.0, main = paste( "network model of", name.groups[i]))
}
```


```{r}
network.value <- list()

for(i in 1:length(g)){

  E(g[[i]])$weight <- as.matrix(abs(results_sub.by.group[[i]][, 4]))

  network.value[[i]] <- data.frame(
  id = V(g[[i]])$name, # name of variables
  deg = degree(g[[i]]), # degree
  bet = betweenness(g[[i]]), # betweenness
  clo = closeness(g[[i]]), # closeness
  eig = evcent(g[[i]])$vector,# egin.cent
  cor = graph.coreness(g[[i]]), # coreness
  tra = transitivity(g[[i]], type = c("local")) # cluster coefficients
)
network.value[[i]]$res <- as.vector(lm(eig ~ bet, data = network.value[[i]])$residuals)
network.value[[i]]$group <- name.groups[i]
}

net.vertice.data <- as.data.frame(do.call("rbind", network.value))
row.names(net.vertice.data) <- NULL
```

```{r}
net.vertice.data$id <- as.factor(net.vertice.data$id)
net.vertice.data$group <- as.factor(net.vertice.data$group)
m.net.vertice.data <- melt(net.vertice.data)

# compare degree

m.net.vertice.data %>% filter(variable == "deg") %>% 
   ggplot(aes(x= value, y = id)) + 
        geom_point(size = 3, color ="blue") +
   facet_wrap(~group) +
        theme_bw() +
        theme(panel.grid.major.x =  element_blank(),
              panel.grid.minor.x =  element_blank(),
              panel.grid.major.y = element_line(color = "grey", linetype = 3)) +
  ggtitle("Degree of each node in the injury profile network")

m.net.vertice.data %>% filter(variable == "bet") %>% 
   ggplot(aes(x= value, y = id)) + 
        geom_point(size = 3, color ="blue") +
   facet_wrap(~group) +
        theme_bw() +
        theme(panel.grid.major.x =  element_blank(),
              panel.grid.minor.x =  element_blank(),
              panel.grid.major.y = element_line(color = "grey", linetype = 3)) +
   ggtitle("Betweenness of each node in the injury profile network")

 m.net.vertice.data %>% filter(variable == "bet") %>% 
   ggplot(aes(x= value, y = id)) + 
        geom_point(size = 3, color ="blue") +
   facet_wrap(~group) +
        theme_bw() +
        theme(panel.grid.major.x =  element_blank(),
              panel.grid.minor.x =  element_blank(),
              panel.grid.major.y = element_line(color = "grey", linetype = 3)) +
   ggtitle("Betweenness of each node in the injury profile network")

m.net.vertice.data %>% filter(variable == "clo") %>% 
   ggplot(aes(x= value, y = id)) + 
        geom_point(size = 3, color ="blue") +
   facet_wrap(~group) +
        theme_bw() +
        theme(panel.grid.major.x =  element_blank(),
              panel.grid.minor.x =  element_blank(),
              panel.grid.major.y = element_line(color = "grey", linetype = 3)) +
   ggtitle("Closeness of each node in the injury profile network")

m.net.vertice.data %>% filter(variable == "eig", group == "IDN_1") %>% 
   ggplot(aes(x= value, y = reorder(id, value))) + 
        geom_point(size = 3, color ="blue") +
   facet_wrap(~group) +
        theme_bw() +
        theme(
              panel.grid.major.x =  element_blank(),
              panel.grid.minor.x =  element_blank(),
              panel.grid.major.y = element_line(color = "grey", linetype = 3)
              ) +
   ggtitle("Eigenvector of each node in the injury profile network")

m.net.vertice.data %>% filter(variable == "cor", group == "IDN_1") %>% 
   ggplot(aes(x= value, y = reorder(id, value))) + 
        geom_point(size = 3, color ="blue") +
   facet_wrap(~group) +
        theme_bw() +
        theme(
              panel.grid.major.x =  element_blank(),
              panel.grid.minor.x =  element_blank(),
              panel.grid.major.y = element_line(color = "grey", linetype = 3)
              ) +
   ggtitle("Eigenvector of each node in the injury profile network")

```


One method is to plot / regress eigenvector centrality on betweenness and examine the residue.

- An actor with high betweenness and low eigenvector centrality may be an importanct gatkeeper to a central actor

- An actor with low betweeness and hight eigenvector centrality may have unique access to central actor

```{r plot BtnVSEgv}
for(i in 1:length(network.value)){
 plot <- ggplot(
  network.value[[i]], aes(x = bet, y = eig,
               label = rownames(network.value[[i]]),
               color = res,
               size = abs(res))) +
    xlab("Betweenness Centrality") +
    ylab("Eigencvector Centrality") +
    geom_text() +
    ggtitle(paste("Key Actor Analysis for Injuiry Profiles of", name.groups[i]))

print(plot) 
}
```

```{r Network pro}
# dd <- degree.distribution(g[[1]], cumulative = T, mode = "all")
# plot(dd, pch = 19, cex = 1, col = "orange", xlab = "Degree", ylab = "Cumulative Frequesncy")
# distances(g[[1]])
# #shortest_paths(g[[1]], 5)
# all_shortest_paths(g[[1]], 1, 6:8)
# mean_distance(g[[1]])
# hist(degree(g[[1]]),  col = "lightblue", xlim = c(0, 10), xlab = "Vertex Degree", ylab = "Frequency", main = "")
# hist(graph.strength(g[[1]]),  col = "pink", xlim = c(0, 5), xlab = "Vertex strength", ylab = "Frequency", main = "")

global.prop <- NULL

for(i in 1:length(g)){
adj.mat <- as.matrix(get.adjacency(g[[i]], attr = "weight"))
new.global.prop <- as.data.frame(networkConcepts(adj.mat)$Summary)[1]
names(new.global.prop) <- name.groups[i]
global.prop <- c(global.prop, new.global.prop)
#net.result <- fundamentalNetworkConcepts(mat[[i]])
#conformityBasedNetworkConcepts(mat)
}

sum.global <- as.data.frame(do.call("cbind", global.prop))
rownames(sum.global) <- c("Density", "Centralization", "Heterogeneity", "Mean ClusterCoef", "Mean Connectivity")
```


```{r}
# cleate all the ppssible pair of the variables
IP.list <- NULL
  for(i in 2:(dim(IP.data)[2]-1)){
     for(j in (i+1):(dim(IP.data)[2])){
      new.row <- c(names(IP.data)[i], names(IP.data)[2 + j])
      IP.list <- rbind(IP.list, new.row)			
    }
  }

IP.list <- as.data.frame(IP.list)
names(IP.list) <- c("var1", "var2")
IP.list$rho <- 0
```


```{r}
results$newrho <- ifelse(abs(results$rho) > 0.25, results$rho, 0)
 
IDN1 <- results %>% filter(trt == "IDN_1")
 IDN2 <- results %>% filter(trt == "IDN_2")
 IND1 <- results %>% filter(trt == "IND_1")
 IND2 <- results %>% filter(trt == "IND_2")
 THA1 <- results %>% filter(trt == "THA_1")
 THA2 <- results %>% filter(trt == "THA_2")
 VNM1 <- results %>% filter(trt == "VNM_1")
 VNM2 <- results %>% filter(trt == "VNM_1")
 PHL1 <- results %>% filter(trt == "PHL_1")

```


